#!/usr/bin/python

import os, sys, getopt, random, logging, time, numpy, math, linecache

TIME = time.time()
GENERATOR = 'generador.cpp'

# Dataset will be generated with CONS_DATASET 
# times the number of rows of the testcase  
CONS_DATASET = 3

help_text = '''Usage:
gen_dyn [options] -o <outputfile> -s <size> -d <dimentions> 
gen_dyn  -o <outputfile> --autodataset
gen_dyn  -o <outputfile> --autotiny

Options:
 -v                     verbose output 

 --arrivals <num>       sepcify how many arrivals per tuple will be generated
                        by default poisson distribution is used  

 --poissparameter <num> poisson parameter to use when generating arrival events.
                        The parameter specifies average arrival events per minute
                        (defaut is a random number between 1 and 10)

 --poissarray <string>  specify a string containg poisson parameters separated
                        with an '%' (used when different poisson parameters 
                        will be used to generate arrival events) 
                        example: --poissarray 5%2%10 for 3 dimentions.

 --expparameter <num>   exponential parameter to use when generating arrival 
                        timestamps (defaut is a random number between 1 and 20)

  --exparray <string>   specify a string containg exponential parameters separated
                        with an '%' (used when different exponential parameters 
                        will be used to generate arrival timestamps) 
                        example: --exparray 0.5%2%4 for 3 dimentions.

 --testcases <num>      generate different testcases according to the same file  

 --leavereport          leave a report file describing the parameters used to 
                        create the testcase(s) 

 --resume  <file>       resume execution from specified tmp file 

 --dontdelete           keep kossmann tmp file (default is delete the file)

 --autodataset          generate medium to small random parameters for the 
                        entire dataset (to generate a quick and dirty dataset
                        for tests)

  --autotiny            like --autodataset but generating a tiny dataset
                        (to generate a quick and dirty tiny dataset for control)

  --anticorrelated      use anticorrelated data distribution
  --correlated          use correlated data distribution
  --uniform             use uniform data distribution (default)

 --distributearr        data distribution refers to arrivals (default)
 --distributedim        data distribution refers to dimentions 

  --rarrival            generate random arrival times, instead of exponential.
'''

def print_verbose_message(msg):
    if G_VERBOSE:
        sys.stdout.write(msg)
        sys.stdout.flush()


def get_options(argv):
    try:
        long_options = ['exparray=', 'expparameter=','autodataset', 'autotiny',\
                            'anticorrelated', 'correlated', 'uniform',\
                            'distributearr', 'distributedim', 'rarrival',\
                        'poissarray=','poissparameter=','arrivals=','testcases=',\
                        'leavereport','resume=','dontdelete']
        options, args = getopt.getopt(argv,"o:s:d:v",long_options)
        if not options:         
            print help_text
            sys.exit(1)
    except getopt.GetoptError:
        print help_text
        sys.exit(2)
    return options

def check_size(arg):
    if '.' in arg or '-' in arg:
        raise Exception('Error: size value (-s) value must be a positive'+\
                            'integer.')
    try: 
        int(arg)
    except ValueError:
        raise Exception('Error: size value (-s) is not a number')

def check_dimentions(arg):    
    if '.' in arg or '-' in arg:
        raise Exception('Error: dimention value (-d) value must be a positive'+\
                            'integer.')
    try: 
        d = int(arg)
    except ValueError:
        raise Exception('Error: dimention value (-d) is not a number')
    if d < 3 or d > 10:
        raise Exception('Error: dimention value (-d) must be between 3 and 10')


def check_arrivals(arg):
    if '.' in arg or '-' in arg:
        raise Exception('Error: arrival value (-a) value must be a positive'+\
                            'integer.')
    try: 
        int(arg)
    except ValueError:
        raise Exception('Error: arrival value (-a) is not a number')


def check_outputfile(arg):
    if os.path.isfile(arg) or os.path.isfile(arg + '_0'):
        ans = raw_input('Warning: file "{0}" exists, continue? [Y/n]: '.format(arg))
        while not (ans == 'y' or ans == 'n' or ans == ''):
            ans = raw_input("Please type 'y' or 'n': ")
        if ans == 'n':
            sys.exit()

def check_tmpfile(arg):
    if not os.path.isfile(arg):
        raise Exception('Error: tmp file {0} does not exist'.format(arg))


def check_exp_parameter(arg):
    if '-' in arg:
        raise Exception('Error: exponential parameter(s) must be a positive'+\
                            ' number')
    try: 
        f = float(arg)
    except ValueError:
        raise Exception('Error: exponential parameter(s) is not a number.')

    if f == 0.0:
        raise Exception('Error: exponential parameter(s) must be greater than'+\
                            ' zero.')


def check_exp_array(arg,options):
    exp_array = arg.split('%')
    dimentions = int([y for x,y in options if x == '-d'][0])
    if len(exp_array) != dimentions:
        raise Exception('Error: --exparray has bad format (is the number of '+\
                            'values in the array equal to the number of '+\
                            'dimentions?)')
    for num in exp_array:
        check_exp_parameter(num)

    opt_list = [x for x,y in options]
    if '--expparameter' in opt_list:
        raise Exception('Error: --expparameter and --exparray cannot be '+\
                            'seleceted together')

def check_not_arrivals(options):
    opt_list = [x for x,y in options]
    if '--arrivals' in opt_list:
        raise Exception('Error: --arrivals cannot be selected along with '+\
                        '--poissparameter or --poissarray')

def check_poiss_parameter(arg):
    if '-' in arg or '.' in arg:
        raise Exception('Error: poisson parameter(s) must be a positive '+\
                            'integer number')
    try: 
        f = int(arg)
    except ValueError:
        raise Exception('Error: poisson parameter(s) is not a number.')

    if f == 0:
        raise Exception('Error: poisson parameter(s) must be greater than'+\
                            ' zero.')

def check_testcases(arg):
    if '-' in arg or '.' in arg:
        raise Exception('Error: testcases parameter must be a positive '+\
                        'integer number')
    try: 
        f = int(arg)
    except ValueError:
        raise Exception('Error: testcases parameter is not a number.')

    if f == 0:
        raise Exception('Error: testcases parameter must be greater than'+\
                        ' zero.')

def check_poiss_array(arg,options):
    poiss_array = arg.split('%')
    dimentions = int([y for x,y in options if x == '-d'][0])
    if len(poiss_array) != dimentions:
        raise Exception('Error: --poissarray has bad format (is the number of '+\
                            'values in the array equal to the number of '+\
                            'dimentions?)')
    for num in poiss_array:
        check_poiss_parameter(num)

    opt_list = [x for x,y in options]
    if '--poissparameter' in opt_list:
        raise Exception('Error: --poissparameter and --poissarray cannot be '+\
                            'seleceted together')



def check_auto(options):
    opt_list = [x for x,y in options]

    if len(options) > 2:
        counter = len(options)

        if '-v' in opt_list:
            counter = counter - 1

        if '--testcases' in opt_list:
            counter = counter - 1

        if '--leavereport' in opt_list:
            counter = counter - 1

        if '--resume' in opt_list:
            counter = counter - 1

        if '--dontdelete' in opt_list:
            counter = counter - 1

        if counter > 2:
            raise Exception('Error: options --autodataset or '+\
                            '--autotiny cannot be selected with '+\
                            'any other option')
        

def check_options(options):
    auto = False
    opt_list = [x for x,y in options]
    if '-o' not in opt_list:
        raise Exception('Error: no output file selected')
    for opt, arg in options:
        if opt == '-s':
            check_size(arg)
        elif opt == '-d':
            check_dimentions(arg)
        elif opt == '-o':
            check_outputfile(arg)
        elif opt == '--resume':
            check_tmpfile(arg)
        elif opt == '--poissparameter':
            check_poiss_parameter(arg)
            check_not_arrivals(options)
        elif opt == '--testcases':
            check_testcases(arg)
        elif opt == '--poissarray':
            check_poiss_array(arg,options)
            check_not_arrivals(options)
        elif opt == '--arrrivals':
            check_arrivals(arg)
        elif opt == '--expparameter':
            check_exp_parameter(arg)
        elif opt == '--exparray':
            check_exp_array(arg,options)
        elif opt == '--autodataset' or opt == '--autotiny':
            check_auto(options)
            auto = True

    if not auto:
        if '-s' not in opt_list:
            raise Exception('Error: unless --autodataset or --autotiny are '+\
                                'selected size value (-s) must be specified')
        if '-d' not in opt_list:
            raise Exception('Error: unless --autodataset or --autotiny are '+\
                                'selected dimentions value (-d) must be specified')

def set_defaults():
    global G_DATA_DIST_APPLICATION
    global G_DATA_DIST
    global G_POISS_PARAMETER
    global G_ARRIVALS
    global G_EXP_PARAMETER
    global G_AUTO
    global G_TINY
    global G_RANDOM_ARRIVALS
    global G_TESTCASES
    global G_LEAVE_REPORT
    global G_VERBOSE
    global G_DELETE_TMP
    global G_RESUME

    G_RESUME = None
    G_DELETE_TMP = True

    G_VERBOSE = False

    
    G_LEAVE_REPORT = False

    G_DATA_DIST_APPLICATION = 'arrivals'        

    G_DATA_DIST = 'E'

    G_POISS_PARAMETER = random.randint(1,100)
    G_ARRIVALS = None
    G_EXP_PARAMETER = random.random() * 20
    G_TESTCASES = 1
    
    G_AUTO = False
    G_TINY = False

    G_RANDOM_ARRIVALS = False


def parse_probability_options(options):
    global G_EXP_PARAMETER
    global G_EXP_ARRAY
    global G_POISS_PARAMETER
    global G_POISS_ARRAY
    global G_ARRIVALS
    

    for opt, arg in options: 
      if opt == '--expparameter':
          G_EXP_PARAMETER = float(arg)

      elif opt == '--exparray':
          G_EXP_PARAMETER = None
          G_EXP_ARRAY = [float(x) for x in arg.split('%')]

      elif opt == '--arrivals':  
          G_ARRIVALS = int(arg)
          G_POISS_PARAMETER = None

      elif opt == '--poissparameter':
          G_POISS_PARAMETER = int(arg)

      elif opt == '--poissarray':
          G_POISS_PARAMETER = None
          G_POISS_ARRAY = [int(x) for x in arg.split('%')]          

      elif opt == '--rarrival':
          global G_RANDOM_ARRIVALS
          G_EXP_PARAMETER = None
          G_EXP_ARRAY = None
          G_RANDOM_ARRIVALS = True

def parse_datadist_options(options):
    global G_DATA_DIST

    for opt, arg in options:        
      if opt == '--anticorrelated':
          raise NotImplementedError 
          G_DATA_DIST = 'A'
      elif opt == '--correlated':
          raise NotImplementedError 
          G_DATA_DIST = 'C'
      elif opt == '--distributedim':
          raise NotImplementedError 
          global G_DATA_DIST_APPLICATION
          G_DATA_DIST_APPLICATION = 'dimentions'


def parse_short_options(options):
    for opt, arg in options:
      if opt == '-s':
          global G_SIZE
          G_SIZE = int(arg)
      elif opt == '-d':
          global G_DIMENTIONS
          G_DIMENTIONS = int(arg)

def set_autodataset_values():
    global G_DIMENTIONS
    global G_SIZE
    global G_ARRIVALS
    global G_POISS_PARAMETER
    
    G_POISS_PARAMETER = None

    if G_TINY:
        max_dim = 3

        min_size = 4
        max_size = 7

        min_arr = 3
        max_arr = 4

    else:
        max_dim = 5

        min_size = 10000
        max_size = 100000
        
        min_arr = 20
        max_arr = 50

    G_DIMENTIONS = random.randint(3,max_dim)
    G_SIZE = random.randint(min_size,max_size)
    G_ARRIVALS = random.randint(min_arr,max_arr)


def parse_auto(options):
    global G_AUTO
    global G_TINY
    G_AUTO = False

    for opt, arg in options:
        if opt == '--autodataset':
            G_AUTO = True
            G_TINY = False
            set_autodataset_values()
        elif opt == '--autotiny':
            G_AUTO = True
            G_TINY = True
            set_autodataset_values()
    return G_AUTO


def parse_input(options):
    global G_VERBOSE
    global G_OUTPUTFILE
    global G_TESTCASES
    global G_LEAVE_REPORT
    global G_RESUME
    global G_DELETE_TMP

    set_defaults()

    for opt, arg in options:
        if opt == '-v':            
            G_VERBOSE = True
        elif opt == '-o':
            G_OUTPUTFILE = arg
        elif opt == '--testcases':
            G_TESTCASES = int(arg)
        elif opt == '--leavereport':
            G_LEAVE_REPORT = True
        elif opt == '--resume':
            G_RESUME = arg
        elif opt == '--dontdelete':
            G_DELETE_TMP = False

    if not parse_auto(options):
        parse_short_options(options)
        parse_datadist_options(options)
        parse_probability_options(options)


def report_input():
    if G_LEAVE_REPORT:
        of = open('{0}_report'.format(G_OUTPUTFILE),'w')
                    
    if G_VERBOSE or G_LEAVE_REPORT:
        print 'Generating dataset according to:'        
        for variable in globals():
            if 'G_' in variable:
                value = eval(variable)
                line = str(variable[2:]) +  ':\t' + str(value)
                if G_LEAVE_REPORT:
                    of.write(line + '\n')
                if G_VERBOSE:
                    print line


def call_kossman():
    if G_RESUME is not None:        
        return 

    if not os.path.isfile(GENERATOR):
        raise Exception('Error: kossman generator does exist')

    if not os.path.isfile('generador'):
        os.system('g++ {0} -o generator'.format(GENERATOR))

    if G_DATA_DIST_APPLICATION == 'arrivals':
        if G_TESTCASES > 1:
            size = G_SIZE * G_DIMENTIONS * CONS_DATASET
        else:
            size = G_DIMENTIONS * G_SIZE
        dimentions = G_ARRIVALS

    if G_VERBOSE:
        sys.stdout.write('\nCreating tmp file with Kossmann generator...')        
        sys.stdout.flush()

    os.system('./generator {0} {1} {2} tmp_{3} > /dev/null'.format(dimentions, G_DATA_DIST,size,TIME))

    if G_VERBOSE:
        sys.stdout.write(' done\n')
        sys.stdout.flush()
        
    else:
        pass


def create_poisson_arrival():    
    arrivals = []
    max_arr = []

    if G_RANDOM_ARRIVALS:

        for i in range(0,G_DIMENTIONS):
            dim_random_events = random.sample(xrange(1,10),G_SIZE)
            arrivals.append(dim_random_events)            
            max_arr.append(max(dim_random_events))

    else:      
        if G_POISS_PARAMETER is not None:
            # Single poisson parameter for all dimentions
            for i in range(0,G_DIMENTIONS):
                numpy_arr = numpy.random.poisson(G_POISS_PARAMETER,G_SIZE)
                dim_poiss_events = numpy_arr.tolist()
                arrivals.append(dim_poiss_events)
                max_arr.append(max(dim_poiss_events))
            
        else:
            # A different poisson parameter for each dimetion
            for i in range(0,G_DIMENTIONS):
                numpy_arr = numpy.random.poisson(G_POISS_ARRAY[i],G_SIZE)
                dim_poiss_events = numpy_arr.tolist()
                arrivals.append(dim_poiss_events)
                max_arr.append(max(dim_poiss_events))

    overall_max = max(max_arr)
    return (overall_max,arrivals)



def generate_poisson_arrivals():
    arrivals = []
    max_arr = [] 
    global G_ARRIVALS
    for i in range(0,G_TESTCASES):
        tpl = create_poisson_arrival()
        max_arr.append(tpl[0])
        arrivals.append(tpl[1])

    G_ARRIVALS = max(max_arr)
    return arrivals
    


def create_fixed_arrival():    
    arrivals = []

    for i in range(0,G_DIMENTIONS):
        dim_list = []
        for j in range(0,G_SIZE):
            dim_list.append(G_ARRIVALS)

        arrivals.append(dim_list)

    return arrivals

def generate_fixed_arrivals():
    arrivals = []
    for i in range(0,G_TESTCASES):        
        arr_list = create_fixed_arrival()
        arrivals.append(arr_list)

    return arrivals
    

def generate_timestamps(size):
    if G_POISS_PARAMETER != None:
        numpy_arr = numpy.random.exponential(G_POISS_PARAMETER,size)
    else:
        numpy_arr = numpy.random.exponential(G_ARRIVALS,size)
    timestamps = numpy_arr.tolist()

    return timestamps
    

def read_long_file(file_name):
    testcase_row_num = G_SIZE * G_DIMENTIONS
    print_verbose_message('Creating random list...')
    rows_index = sorted(random.sample(range(1, (testcase_row_num * CONS_DATASET)\
                                            + 1), testcase_row_num))
    print_verbose_message('done\n')

    print_verbose_message('Reading tmp file...\n')
    rows = []
    t = len(rows_index)
    a = 0.0
    with open(file_name,'r') as tmpfile:
        for i,line in enumerate(tmpfile):
            print_verbose_message('\r {0}%'.format((a * 100) / t))
            if i in rows_index:            
                line_parsed = line.split()
                rows.append(line_parsed)
                a = a + 1
            
    print_verbose_message('\r done\n')

    return rows

def read_medium_file(file_name):
    testcase_row_num = G_SIZE * G_DIMENTIONS
    rows_index = sorted(random.sample(range(0, testcase_row_num \
                                            * CONS_DATASET), testcase_row_num))
    t = len(rows_index)
    a = 0
    rows = []
    for i in rows_index:
        print_verbose_message('\r{0}%'.format((a* 100) / t))
        # Rows are slided two positions, the first one beacuse 
        # the first line of the file is not used. 
        # The second because linecache cannot read line 0

        line = linecache.getline(file_name, i + 2)
        if line == '':
            raise Exception('Error: Problem with linecache with line {0}'\
                            .format(i))
        line_parsed = line.split()
        rows.append(line_parsed)
        a = a + 1

    linecache.clearcache()

    print_verbose_message('\r done\n')
    return rows

    
def big_file_warning():
    msg = '''Warning: Parameters selected led to a very big file
    and it will take a long time to generate your testcase.
    Do you still want to continue? [N/y]: '''

    ans = raw_input(msg)
    while not (ans == 'y' or ans == 'n' or ans == ''):
        ans = raw_input("Please type 'y' or 'n': ")
    if ans == 'y':
        return
    sys.exit()
    
    

def read_single_testcase(file_name):
    tmp_file = open(file_name,'r')
    rows = []
    # skip first row
    tmp_file.readline()
    for line in tmp_file:
        line_parsed = line.split()
        rows.append(line_parsed)
        
    tmp_file.close()
    return rows



def select_rows(testcase):
    if G_RESUME is not None:
        file_name = G_RESUME
    else:
        file_name = 'tmp_{0}'.format(TIME)
        
    big_file = False

    print os.stat(file_name).st_size
    if os.stat(file_name).st_size > 1000000000:
        big_file_warning()
        big_file = True

    if G_TESTCASES != 1:
        print_verbose_message('Selecting columns for testcase #{0}...\n'\
                              .format(testcase))
        if big_file:
            rows = read_long_file(file_name)
        else:
            rows = read_medium_file(file_name)
    else:
        rows = read_single_testcase(file_name)

    random.shuffle(rows)
    return rows


def write_output_file(data_list , testcase_num):    
    print_verbose_message('Writing output file... ')
    if testcase_num != None:
        file_name = G_OUTPUTFILE + '_' + str(testcase_num)            
    else:
        file_name = G_OUTPUTFILE

    testcase_tuples = str(sorted(data_list))[1:-1]

    of = open(file_name,'w')
    of.write(testcase_tuples)
    of.close()
    print_verbose_message(' done\n')




def create_dataset(arrivals, testcase_num=None):
    rows = select_rows(testcase_num)    
    tuples = G_SIZE   
    dims = range(1,G_DIMENTIONS + 1)
    dim = dims.pop(0)
    result = []
    
    print_verbose_message('Organizing dataset....\n')
    
    t = G_SIZE * G_DIMENTIONS 
    s = 0
    for dim in range(1,G_DIMENTIONS + 1):        
        tuple_arr = arrivals.pop(0)
        for tuple_id in range(0,G_SIZE):
            values = rows.pop(0)
            arr = tuple_arr.pop(0)
            timestamps = generate_timestamps(arr)
            ts_acum = 0.0

            s = s + 1
            p = (s * 100) / t
            print_verbose_message('\r{0}%'.format(p))

            for i in range(0,arr):
                val = values.pop(0)
                ts = timestamps.pop(0)
                ts_acum = ts_acum + ts               
                result.append((ts_acum, dim, float(val),))

    print_verbose_message('\r done\n')
    write_output_file(result, testcase_num)

def generate_datasets(arrival_arr):
    if G_TESTCASES != 1:
        testcase = 0
        for arrival in arrival_arr:
            create_dataset(arrival,testcase)
            testcase = testcase + 1
    else:
        create_dataset(arrival_arr.pop())
    
    if G_DELETE_TMP:
        if G_RESUME is not None:
            os.system('rm {0}'.format(G_RESUME))
        else:
            os.system('rm tmp_{0}'.format(TIME))

        
def main(argv):
    options = get_options(argv)
    check_options(options)
    parse_input(options)

    if G_VERBOSE:
        report_input()

    if not G_ARRIVALS:
        arrival_arr = generate_poisson_arrivals()    
    else:
        arrival_arr = generate_fixed_arrivals()    


    call_kossman()

    generate_datasets(arrival_arr) 

    if G_VERBOSE:
        print '\nEverything done!'

if __name__ == "__main__":
    main(sys.argv[1:])
